[{"item_id": 21107817, "text": "At this point, when I see libraries like this all I can think is \u201doh good, my compile times aren\u2019t long enough, lets make EVERY INTEGER a template\u201d.<p>Also, while I can reasonably beliveve that most of the overhead goes away at -O2 or -O3, this has to just trash performance for debug builds, which is not unimportant.", "by": "OskarS"}, {"item_id": 21109121, "text": "Oh, that&#x27;s nice. I wanted that decades ago, when I was working on program verification. Templates have made a lot of progress if this can be done entirely in C++ templates. I once wrote, but never published, &quot;Type Integer Considered Harmful&quot;, back when there were still 16-bit integers in most C programs. I wanted ranges on everything, like Ada. As a practical matter, integer overflow became less of an issue with 32-bit.<p>Sizes of intermediates are a big issue. When you write<p><pre><code>    int_32 a,b,c,n;\n    ...\n    n = (a*b)*c;  \n</code></pre>\nhow big is each part? My thinking on this was that it&#x27;s the compiler&#x27;s job to prevent overflow in intermediate values where the final result will not overflow. So, above, you&#x27;d have to compute (m * n) as a 64-bit product, do a 64-bit divide, and only then check that the result fit in n.<p>is legal to compute in 32-bit, but requires overflow checking on the intermediates. If an overflow occurs, there will be an overflow in the result. (Although, the case where some values are zero is an issue. Suppose a * b overflows but c is zero so it doesn&#x27;t matter. That&#x27;s probably an error.)<p>Sometimes you have to use larger sized intermediates. For<p><pre><code>    int_32 m,n,p;\n    ...\n    n = (m * n) &#x2F; p;\n</code></pre>\nhow big is each part? Above, you&#x27;d have to compute (m * n) as a 64-bit product, do a 64-bit divide, and only then check that the result fit in n.<p>To do this right, you need something in the compiler that can do basic reasoning about machine arithmetic. Something that knows, for example, that<p><pre><code>    uint_16 n;\n    ...\n    n = (n + 1) % 65536;\n</code></pre>\ncannot really overflow and can be optimized down to a plain unsigned 16-bit add.<p>If you try to to this through linguistic type analysis only, it&#x27;s not going to be satisfactory.\nYou need to be able to prove out inequalities.", "by": "Animats"}, {"item_id": 21107378, "text": "Maybe Ada&#x27;s approach of every number type requiring explicit bounds is a good one.", "by": "TazeTSchnitzel"}, {"item_id": 21110898, "text": "&gt; The built-in integer types in C++ (int, unsigned, long long, etc.) are mostly unusable<p>Weird.\nIve been programming in C&#x2F;C++ professionally for over a decade and have been using built-in integer types mostly without issue. \nMight want to qualify your hyperbole- is it worth reading on?", "by": "ssalazar"}, {"item_id": 21107352, "text": "&gt; bounded::integer uses built-in integers as the template parameter to determine its bounds. This means that it cannot store an integer larger than an unsigned 64-bit or unsigned 128-bit integer (depending on the platform) or smaller than a signed 64-bit or signed 128-bit integer. This restriction should be removed at some point in the future.<p>So when an overflow happens here I assume it&#x27;s a compile time error (UB due to integer overflow in constexpr context must be diagnosed by the compiler). A handful of multiplications can get you there easily.", "by": "leni536"}, {"item_id": 21108913, "text": "Because of the field I work in I feel this much more keenly with floats. I have been bitten by their excentricities so many times I&#x27;d just much rather have a flexible fixed point type that let me choose how much precision I want on either side of the decimal for a given set of calculations.", "by": "DubiousPusher"}, {"item_id": 21109279, "text": "At first glance it seems to be similar to boost::safe_numerics. Are there significant differences?<p><a href=\"https:&#x2F;&#x2F;github.com&#x2F;boostorg&#x2F;safe_numerics\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;boostorg&#x2F;safe_numerics</a>", "by": "duneroadrunner"}, {"item_id": 21110918, "text": "Reminds me of Pascal having dependent types like<p><pre><code>    var\n      age: 18 ... 130;</code></pre>", "by": "anon91831837"}, {"item_id": 21107957, "text": "It takes quite some amount of stamina to keep on reading after &quot;The built-in integer types in C++ (int, unsigned, long long, etc.) are mostly unusable&quot;", "by": "ur-whale"}, {"item_id": 21107375, "text": null, "by": null}, {"item_id": 21107324, "text": "&gt; The built-in integer types in C++ (int, unsigned, long long, etc.) are mostly unusable because of the lax requirements on bounds.<p>This must be some new definition of the word &#x27;unusable.&#x27;", "by": "golemotron"}, {"item_id": 21107546, "text": null, "by": null}, {"item_id": 21108398, "text": "Ouch", "by": "FpUser"}]