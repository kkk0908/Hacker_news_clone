[{"item_id": 21105506, "text": "Sudoku may be a poor example for illustrating some of the overarching points of this series of blog posts, which I take to be that modern SAT solvers are, as someone described them in a previous thread, &quot;little diamonds of engineering&quot;, that they embody decades of research, that you can exploit their power cheaply and easily, and that it might take significant effort to beat them if you have a non-trivial problem.<p>Since specialized solvers <i>do</i> thrash SAT-based solvers for conventional Sudoku, the author focuses the example less on absolute performance and more on simplicity, rapid prototyping, and comparison to casual non-SAT implementations. But conventional Sudoku is a small problem, and in most cases the SAT-based solver makes so few decisions that it doesn&#x27;t benefit much from CDCL. Consider here[1] the comparison to JCZSolve(ZSolver) that the author mentions in part 1 of the series:<p>For 17-clue puzzles (which are generally very easy), JCZSolve is 50x as fast as Minisat, and it makes on average ~1.9 decisions per puzzle compared to Minisat&#x27;s ~3.0. But if you look at the hardest dataset JCZSolve is only 10x as fast as Minisat, and it makes on average ~365 decisions per puzzle compared to Minisat&#x27;s ~121. I&#x27;m not aware of a highly specialized and optimized Solver for 16x16 clue or larger Sudoku, but given this trend my guess is that it would take a lot of effort to write one that&#x27;s faster than what you get with Minisat for free.<p>[1] <a href=\"https:&#x2F;&#x2F;github.com&#x2F;t-dillon&#x2F;tdoku&#x2F;blob&#x2F;master&#x2F;benchmarks&#x2F;GCE-c2-standard-4_clang-8_O3_native\" rel=\"nofollow\">https:&#x2F;&#x2F;github.com&#x2F;t-dillon&#x2F;tdoku&#x2F;blob&#x2F;master&#x2F;benchmarks&#x2F;GCE...</a>", "by": "53x15"}, {"item_id": 21105059, "text": "SAT solvers are starting to be used as tooling for functional languages - Liquid Haskell uses one for refinement types[1], and Djinn uses one for suggesting functions given a type[2]. Similarly to Djinn, Edwin Brady gave a presentation on using an SMT solver to do live code suggestions&#x2F;implementation inference in the successor to Idris[3].<p>[1] <a href=\"https:&#x2F;&#x2F;ucsd-progsys.github.io&#x2F;liquidhaskell-blog&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;ucsd-progsys.github.io&#x2F;liquidhaskell-blog&#x2F;</a><p>[2] <a href=\"http:&#x2F;&#x2F;lambda-the-ultimate.org&#x2F;node&#x2F;1178\" rel=\"nofollow\">http:&#x2F;&#x2F;lambda-the-ultimate.org&#x2F;node&#x2F;1178</a><p>[3] <a href=\"https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mOtKD7ml0NU\" rel=\"nofollow\">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=mOtKD7ml0NU</a>", "by": "T-R"}, {"item_id": 21095809, "text": "SAT solvers are something I would like to use more, but I feel like I simply never come across real world problems that they work well with. I&#x27;ve tried to use them for program&#x2F;circuit synthesis, but the problem was intractable at any scale larger than a tiny proof-of-concept example.<p>Does anyone have good suggestions for what to use SAT solvers for?", "by": "ladberg"}, {"item_id": 21106035, "text": "Links to previous HN discussions of this article:<p><a href=\"https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19953213\" rel=\"nofollow\">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=19953213</a><p><a href=\"https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17684502\" rel=\"nofollow\">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17684502</a><p><a href=\"https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17778770\" rel=\"nofollow\">https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=17778770</a>", "by": "MaxBarraclough"}, {"item_id": 21105614, "text": "Whenever I read about SAT solvers I think of Prolog and Minikanren and friends. Is there a relationship there? Do they use similar algorithms? I know that backtracking (mentioned in the article) is a thing in Prolog at least.", "by": "vector_spaces"}, {"item_id": 21105185, "text": "If you\u2019re looking for a higher-level interface to SAT, SMT, and general constraint solvers, I can recommend MiniZinc: <a href=\"https:&#x2F;&#x2F;www.minizinc.org&#x2F;index.html\" rel=\"nofollow\">https:&#x2F;&#x2F;www.minizinc.org&#x2F;index.html</a>", "by": "pthariensflame"}, {"item_id": 21104679, "text": "The programming language Mercury which is a functional, predicate based, moded language uses something like a precursor to a sat solver to &quot;run&quot; the program. As in you can ask for the input of a function to make your program true.<p>I imagine all sorts of things can be done like this, and the sat solver is useful for verifying correctness.", "by": "foxes"}, {"item_id": 21104024, "text": "Previously posted 4 months ago and 1 year ago: <a href=\"https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=false&amp;query=modern%20sat%20solvers%3A%20fast&amp;sort=byPopularity&amp;type=story\" rel=\"nofollow\">https:&#x2F;&#x2F;hn.algolia.com&#x2F;?dateRange=all&amp;page=0&amp;prefix=false&amp;qu...</a>", "by": "bcherny"}, {"item_id": 21106558, "text": "How do SAT problems compare to constraint satisfaction problems? Is the latter a subset of the former (with the right modeling)?", "by": "ausbah"}, {"item_id": 21105398, "text": "This is an interesting read, but I&#x27;d be interested in a more large-scale benchmark. Right now it could be possible that the SAT solver is just better optimized for the particular platform, instead of the SAT solver being superior algorithm-wise.", "by": "iflp"}, {"item_id": 21104999, "text": "You can also watch the talk from same author about the same subject here - <a href=\"https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=x2XtpCn0-bM\" rel=\"nofollow\">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=x2XtpCn0-bM</a>", "by": "atilimcetin"}, {"item_id": 21104398, "text": "Can you please share your personal experience of using SAT solver with real world problem?", "by": "vasili111"}, {"item_id": 21103926, "text": "SAT solvers Wikipedia: <a href=\"https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Boolean_satisfiability_problem\" rel=\"nofollow\">https:&#x2F;&#x2F;en.m.wikipedia.org&#x2F;wiki&#x2F;Boolean_satisfiability_probl...</a>", "by": "abbadadda"}, {"item_id": 21107918, "text": "I&#x27;m actually finding part 2 more interesting", "by": "mshockwave"}]