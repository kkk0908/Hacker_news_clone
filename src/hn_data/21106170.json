[{"item_id": 21110698, "text": "My favorite &quot;analog computer&quot; example is finding the balance point of a broom or mop.<p>Start by holding the broom horizontally (so that the shaft is parallel to the floor) and support it between the thumb and fingers of each hand with your hands held about a meter apart.  The palms of your hands should be facing each other, fingers and thumb flat in vertical plane, with the thumbs sticking out to make cradles for the broomstick.<p><pre><code>     side view\n\n          &#x2F;&#x2F;&#x2F;&#x2F;\n      &#x2F;\\o&#x2F;&#x2F;&#x2F;&#x2F;\n      \\    &#x2F;\n       \\  &#x2F;\n\n</code></pre>\nOnce it&#x27;s set up, all you do is gently bring your hands towards each other until they are touching, palm to palm.  The broom will remain balanced on your hands the entire time.<p>As you draw your hands together there will be an unequal amount of friction between the broomstick and each hand.  The side that is further from the center of mass of the broom will have less friction.  The side with less friction will slide.  This changes the weight distribution between your two hands until the friction on the sliding hand has increased [enough] past the friction on the non-sliding hand.  When that happens, the sliding hand stops sliding and the non-sliding hand starts sliding.  The process alternates from hand to hand until, at the end, your hands are touching and the center of mass of the broomstick is [close enough to exactly] between them.<p>- - - -<p>Derp, it&#x27;s on the youtube: <a href=\"https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=B4axmjVFsK8\" rel=\"nofollow\">https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=B4axmjVFsK8</a><p>Stephen Fry...", "by": "carapace"}, {"item_id": 21111925, "text": "I was thinking about how this (and other &quot;physical sorts&quot; mentioned by commenters) sorts instantly by using a physical property of the members, and I began to consider what the computer equivalent would be of &quot;physical sorting&quot;.<p>I think you could take the sort values, use them as memory addresses (or array offsets), and write the original index of each value into its corresponding pointer, then go back and iterate through that entire chunk of memory to find each of them. That might technically be linear time? Really N + M, where N is the number of values and M is their full range. It would have hilariously inefficient usage of memory and a pretty low cap on the range of possible sort values, but still.", "by": "brundolf"}, {"item_id": 21110054, "text": "Linear time O(n) means that as you keep adding numbers to sort, the time taken is bounded by a linear function of how many numbers you have. Since there is an upper bound on the number of spaghetti strands you can hold in your hand, eventually you need to &quot;Slam their lower sides on the table&quot; in batches, and then merge sort the results. However because unlike in merge sort there is an upper bound on the size of the sub lists you use spaghetti sort will actually be O(n^2) instead of O(n log(n)).<p>If you ignore the usual meaning of linear time and restrict yourself to sorting lists of numbers that will fit in your hand, then spaghetti sort always runs in less time that however long it takes to sort the maximum amount of spaghetti you can hold in your hand. i.e. constant time.", "by": "mooshmoosh"}, {"item_id": 21111557, "text": "Sometimes it might not be possible to easily determine which is the longest piece. For inctance if the pieces are on opposite sides ov the bundle, and are very close in height.<p>Also, if you have lots of tiny pieces, and some longer pieces, the bundle won&#x27;t form a nice column. You&#x27;d have to have a minimum length to help form the bundle, then add your number to that minimum length.<p>It seems so strange to me that there are so many algorithms that our brains use, that we don&#x27;t fully understand yet. I self reflect all the time about my own decision making, and the way I see, hear, think, and remember. We all do these things, but what are the underlying algorithms? What data is being stored, how is it represented, and how is it being compared, manipulated,  and updated?", "by": "pontifier"}, {"item_id": 21111234, "text": "This reminds me of my favorite joke algorithm, sleepsort[0].  A trivial implementation looks like this:<p><pre><code>    #!&#x2F;bin&#x2F;bash\n    for int in $@; do  # input must be a list of positive integers\n        (sleep $int; echo $int) &amp;\n    done; wait\n</code></pre>\nI&#x27;m not quite sure how to describe it in terms of big O notation.<p>[0] <a href=\"https:&#x2F;&#x2F;rosettacode.org&#x2F;wiki&#x2F;Sorting_algorithms&#x2F;Sleep_sort\" rel=\"nofollow\">https:&#x2F;&#x2F;rosettacode.org&#x2F;wiki&#x2F;Sorting_algorithms&#x2F;Sleep_sort</a>", "by": "bashinator"}, {"item_id": 21111030, "text": "As an exercise, when could spaghetti sort beat computers?<p>As others have mentioned, your hand can only hold so much pasta (about 10^2). For n=10^2, a computer will easily win. So I&#x27;ll need to abuse logic a bit...<p>Let&#x27;s assume\n- The hand is large enough to hold all the pasta.\n- The linear time operations take about 1 second total (breaking, removing, transcribing).<p>Benchmarks[1] for sorting show TencentSort (which looks like it&#x27;s based on a O(n<i>log(n)) merge sort[2]?) can sort 100TB in 100 seconds, for 100 byte records. So about 10^12 records&#x2F;minute.<p><pre><code>  c*(n*log(n))=time\n  n=10^12\n  time=1min\n  c~=1&#x2F;10^12 minute\n</code></pre>\n(assume log base 2)<p>Solving:<p><pre><code>  (1&#x2F;10^12)*n*log(n)=n\n  (1&#x2F;10^12)*log(n)=1\n  log(n)=10^12\n  log(n)=1,000,000,000,000\n  n=2^1,000,000,000,000\n</code></pre>\nHow big is that?<p>A piece of spaghetti is about 1 gram. 2^1,000,000,000,000 grams is significantly larger than the mass of the observable universe. (10^56 grams, or 2^186 grams).<p>How long is that?<p>2^56 seconds is the age of the universe.<p>Intuitively, this sort of makes sense. For extremely large values of n, log(n) is dwarfed by n so much that it looks like just n. A computer performing a single step of the sort operation is several orders of magnitude faster than any of the human operations. It takes insanely long, and an insanely large n for spaghetti sort to catch up.<p>[1] <a href=\"https:&#x2F;&#x2F;sortbenchmark.org&#x2F;\" rel=\"nofollow\">https:&#x2F;&#x2F;sortbenchmark.org&#x2F;</a>\n[2] <a href=\"http:&#x2F;&#x2F;sortbenchmark.org&#x2F;TencentSort2016.pdf\" rel=\"nofollow\">http:&#x2F;&#x2F;sortbenchmark.org&#x2F;TencentSort2016.pdf</a>", "by": "robbya"}, {"item_id": 21111117, "text": "Related: One of my favorite realizations back in college was that insertion sort in real life is an optimal sort. The inefficiency in computers is that you need to slide all of the values down a place one by one as you insert numbers. In real life, the values just get shoved down in parallel.<p>Helped me understand why people default to such an inefficient algorithm when learning about sorting.", "by": "war1025"}, {"item_id": 21109968, "text": "Isn&#x27;t there also another IRL sorting algorithm that works with beads and gravity?<p>EDIT: I thought couldn&#x27;t remember the name, turns out it&#x27;s actually <i>bead sort</i> aka <i>gravity sort</i>. Sometimes things are as simple as they seem.<p><a href=\"https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bead_sort\" rel=\"nofollow\">https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Bead_sort</a>", "by": "vanderZwan"}, {"item_id": 21111562, "text": "I loved the original article in Sci-Am. I believe there were at least two articles on these &quot;analog gadgets&quot;.<p>Found one: <a href=\"http:&#x2F;&#x2F;www.softouch.on.ca&#x2F;kb&#x2F;data&#x2F;Scan-130202-0003.pdf\" rel=\"nofollow\">http:&#x2F;&#x2F;www.softouch.on.ca&#x2F;kb&#x2F;data&#x2F;Scan-130202-0003.pdf</a><p>Also: <a href=\"http:&#x2F;&#x2F;dataphys.org&#x2F;list&#x2F;dewdneys-analog-gadgets&#x2F;\" rel=\"nofollow\">http:&#x2F;&#x2F;dataphys.org&#x2F;list&#x2F;dewdneys-analog-gadgets&#x2F;</a>", "by": "JKCalhoun"}, {"item_id": 21111377, "text": "I believe the worst-case asymptotic time complexity of spaghetti sort is O(n^2).<p>The algorithm works for any input list, so I will pick a hard class of inputs: The list shall be some permutation of [1, 2, 3, ..., n].<p>The sum of the spaghetti lengths is 1+2+3+...+n, which is in O(n^2). You need to spend O(n^2) effort to gather the flour to make the spaghetti. Hence this sets a lower bound on the overall algorithm.", "by": "nayuki"}, {"item_id": 21110224, "text": "Has someone calculated at what n I will sort faster than my PC?", "by": "clktmr"}, {"item_id": 21106243, "text": "This is silly. The linear parts are just I&#x2F;O, and the actual sorting happens in constant time by magic.", "by": "ziofill"}, {"item_id": 21109947, "text": "So radix sort IRL.", "by": "CoolGuySteve"}]