[{"item_id": 21098319, "text": "I tend to disagree that RAII is used only used for memory. We&#x27;ve RAII wrappers for locks, file handles etc. all the time in our code base.<p>Also it&#x27;s impractical to only have POD structs i.e. structs with no pointer pointing to the free store.<p>Good otherwise.<p>Nice colours and theming though :)", "by": "legends2k"}, {"item_id": 21099130, "text": "I disagree with the &quot;always typedef structs&quot; part. Personally I often find it nicer to have the &quot;struct&quot; there as part of the name. Partly because people sometimes typedef a <i>pointer</i> to the underlying struct type, and that can cause some issues.<p>The part about the author&#x27;s take on RAII is interesting, but it would really merit a separate post with code examples.", "by": "tom_mellior"}, {"item_id": 21098153, "text": "Very nice article!<p>Minor nit:\n&gt; there\u2019s now a standardized bool with true&#x2F;false (also not built-in but defined in stdbool.h)<p>C99 introduced _Bool, which is a built-in.<p>stdbool.h defines bool as an alias to it (unless compiling as C++, which then gets left alone as the native C++ bool).", "by": "dottrap"}, {"item_id": 21096829, "text": "This is a nicely written piece. Worth your time if you program much c, c++, rust, D, go etc.", "by": "harry8"}, {"item_id": 21102450, "text": "From the article: &quot;The \u2018Modern C\u2019 I\u2019m talking about here is not modern at all, but already two decades old.&quot;<p>No kidding!<p>Still, anybody coding C is still, within epsilon, coding C++, but badly.", "by": "ncmncm"}, {"item_id": 21097554, "text": "I cannot really read the article. It&#x27;s too depressing because I&#x27;m still stuck with C++03.<p>But even before the newer C++ became widespread, I wondered why it lacks behind C99 in some aspects. And it seems that this hasn&#x27;t changed much:<p>&gt; The good news is that C++20 is getting basic designated initialization too, the bad news is that it will only be a very limited subset of the C99 feature", "by": "jackewiehose"}, {"item_id": 21100682, "text": "tl;dr:<p>1) use -Wall, -Werror, -W4.<p>I suggest -pedantic as well; surely you were already using the first two?<p>2) designed initializers are nice<p>Indeed, they are.<p>3) you don&#x27;t need RAII because it&#x27;s only for memory<p>False. C++ is my main language, and we  use RAII in many ways: callback invocation, taking locks, pinning cache items, timing segments of code, etc etc.<p>4) small allocations are bad<p>Small allocations are indeed highly inefficient, but this can be addressed using arena allocation. This works because it&#x27;s actually the deallocations and associated defragmentation that are expensive.<p>5) ...so the solution for memory management is not to have structs that contain pointers (?)...<p>You should use the simplest data model possible, but only the simplest data models don&#x27;t require having pointers in structs. For example, any recursive structure would have to have a pointer.<p>6) and all your objects should be allocated from object specific free lists<p>Having an object pool doesn&#x27;t address memory leaks. You would still have to return the object to the pool at some point.", "by": "sagarm"}, {"item_id": 21097222, "text": "I like the color theme of this page very much. Anyone knows what it is?", "by": "objektif"}]